package chess.player

import chess.model.{ Move, MovePiece, MovePieceCapturing, Promote, PromoteCapturing }
import chess.model.{ Configuration, MoveExplorer }
import chess.model.Colour
import chess.model.Position
import chess.model.Pawn
import chess.model.Constants
import chess.model.Queen

// TODO: Ensure all move types can be generated
// TODO: Ensure en-passant moves are generated by StandardMoveExplorer
// TODO: Ensure either castling type can be generated

/**
 * A player that selects moves at random.
 */
class RandomPlayer(val colour: Colour, val conf: Configuration, val explorer: MoveExplorer) extends Player {

  def getMove: Move = {
    val startPositions = conf.locatePieces(colour).toArray
    shuffle(startPositions)
    def isHomeRow(row: Int): Boolean = row == Constants.WHITE_HOME_ROW || row == Constants.BLACK_HOME_ROW
    for (s <- startPositions) {
      var endPositions = explorer.getBasicPositions(s).toArray
      shuffle(endPositions)
      // TODO: Switch to functional approach
      while (endPositions.nonEmpty) {
        val (_, piece, _) = conf.getExistingPiece(s)
        val end = endPositions.head
        val isCapturing = conf.getPiece(end).isDefined
        val move = piece match {
          // TODO: Randomly select between Queen and Knight
          case Pawn() if isHomeRow(end.getRow) =>
            if (isCapturing) PromoteCapturing(s, end, Queen()) else Promote(s, end, Queen())
          case default => if (isCapturing) MovePieceCapturing(s, end) else MovePiece(s, end)
        }
        if (moveAcceptable(move)) return move
        endPositions = endPositions.tail
      }
    }
    throw new RuntimeException("No move found")
  }

  protected def moveAcceptable(move: Move): Boolean = {
    try {
      // TODO: Convert rejectIllegalMove to a query method
      explorer.rejectIllegalMove(move)
      true
    } catch {
      case e =>
        { println("rejected move: " + move + ": " + e) }
        false
    }
  }

  // TODO: Improve shuffling, maybe use Fisher-Yates shuffling algorithm.
  private def shuffle(a: Array[Position]) = {
    java.util.Collections.shuffle(java.util.Arrays.asList(a: _*))
  }
}