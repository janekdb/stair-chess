package chess.player

import chess.model.{ Castle, Move, MovePiece, MovePieceCapturing, Promote, PromoteCapturing }
import chess.model.{ Configuration, MoveExplorer }
import chess.model.Colour
import chess.model.Position
import chess.model.Pawn
import chess.model.Constants
import chess.model.Queen
import chess.model.{ Long, Short }

// TODO: Ensure all move types can be generated
// TODO: Ensure en-passant moves are generated by StandardMoveExplorer
// TODO: Ensure either castling type can be generated

/**
 * A player that selects moves at random.
 */
class RandomPlayer(val colour: Colour, val conf: Configuration, val explorer: MoveExplorer) extends Player {

  def getMove: Move = {
    val startPositions = conf.locatePieces(colour).toArray
    //shuffle(startPositions)
    def isHomeRow(row: Int): Boolean = row == Constants.WHITE_HOME_ROW || row == Constants.BLACK_HOME_ROW
    var moves = List[Move]()
    for (s <- startPositions) {
      var endPositions = explorer.getBasicPositions(s).toArray
      //shuffle(endPositions)
      // TODO: Switch to functional approach
      while (endPositions.nonEmpty) {
        // TODO: Move this assignment in the outer loop
        val (_, piece, _) = conf.getExistingPiece(s)
        val end = endPositions.head
        val isCapturing = conf.getPiece(end).isDefined
        val move = piece match {
          // TODO: Randomly select between Queen and Knight
          case Pawn() if isHomeRow(end.getRow) =>
            if (isCapturing) PromoteCapturing(s, end, Queen()) else Promote(s, end, Queen())
          case default => if (isCapturing) MovePieceCapturing(s, end) else MovePiece(s, end)
        }
        moves = move :: moves
        endPositions = endPositions.tail
      }
    }

    /*
     * Only add castling if the king and rooks are at the correct positions because
     * rejectIllegalMove does not explicitly check the pieces are present.
     */
    for (castlingType <- List(Long, Short)) {
      val ((king, _), (rook, _)) = castlingType.getPositions(colour.homeRow)
      if (List(king, rook).forall(conf.exists(_, colour))) {
        moves = Castle(colour, castlingType) :: moves
      }
    }
    moves = moves filter { moveAcceptable }
    if (moves.isEmpty) throw new RuntimeException("No move found")
    moves(new util.Random().nextInt(moves.size))
  }

  protected def moveAcceptable(move: Move): Boolean = {
    try {
      // TODO: Convert rejectIllegalMove to a query method
      explorer.rejectIllegalMove(move)
      true
    } catch {
      case e => false
    }
  }

  // TODO: Improve shuffling, maybe use Fisher-Yates shuffling algorithm.
  //  private def shuffle(a: Array[Position]) = {
  //    java.util.Collections.shuffle(java.util.Arrays.asList(a: _*))
  //  }
}